#!/usr/bin/env php
<?php

namespace BHayes\CLI;

//to allow this to run any class by name as a global command, first check for a localized autoloader.
if (file_exists('vendor/autoload.php')) {
    include_once 'vendor/autoload.php';
}
//manually include the this version of CLI files in case it is also installed as a project package.
require_once __DIR__ . '/../php/UserResponse.php';
foreach (glob(__DIR__ . '/../php/CLI.php') as $file) {
    require_once $file;
}

if (php_sapi_name() != 'cli') {
    throw new \Error("This is a command line tool only.");
}

$subject = null;

//attempt to construct the subject to run if a class name is specified as argument one.
$potentialClass = $argv[1] ?? null;
if (class_exists($potentialClass)) {
    $subject = new $potentialClass();
} elseif (fileExists($potentialClass)) {
    //attempt to auto-load class based on its file name
    $subject = str_replace(['/', '.php', getcwd()], ['\\','', ''], $potentialClass);
} elseif(file_exists('composer.json') && $composer = file_get_contents('composer.json')) {
    //search for the class in the autoload namespaces
    $decode = json_decode($composer, true) ?: null;

    foreach ($decode['autoload']['psr-4'] ?? [] as $nameSpace => $path) {
        $fullyQualifiedClassName = "$nameSpace$potentialClass";
        if (class_exists($fullyQualifiedClassName)) {
            $subject = new $fullyQualifiedClassName();
            break;
        }
    }
}

//clean up the arguments if we are loading a subject class to run.
if ($subject) {
    unset($argv[1]);
    global $argv;
    global $argc;
    $argv = array_values($argv);
    $argc -= 1;
}


(new CLI($subject))->run();
